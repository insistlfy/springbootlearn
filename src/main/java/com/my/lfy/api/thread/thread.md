> ## Thread  `抢占式调度，具备随机性`
> ### 锁分类
> * 从线程是否需要对资源加锁可以分为 悲观锁 和 乐观锁
> * 从资源已被锁定，线程是否阻塞可以分为 自旋锁
> * 从多个线程并发访问资源，也就是 Synchronized 可以分为 无锁、偏向锁、 轻量级锁 和 重量级锁
> * 从锁的公平性进行区分，可以分为公平锁 和 非公平锁
> * 从根据锁是否重复获取可以分为 可重入锁 和 不可重入锁
> * 从那个多个线程能否获取同一把锁分为 共享锁 和 排他锁
> * [参考链接](https://www.cnblogs.com/Andrew520/p/12149341.html)
>
> * 可重入锁
>> * 定义 : 指以`线程`为单位，当一个线程获取对象锁之后，这个线程可以可以再次获取本对象上的锁，而其他线程是不可以的;
>> * 原理 : 通过为每个锁关联一个`请求计数器`和一个占有它的线程。当计数为0的时候，认为锁是未占用的；线程请求一个未被占有的锁时，JVM将记录锁的占有者，并且将请求计数器置为1
     > 。如果同一个线程再次请求这个锁，计数器将递增。每次占用线程退出同步块，计数器值将递减，直到计数器值为0，锁被释放。
>> * 举例 : synchronized , ReentranLock
> * 公平锁/非公平锁 --都属于排他锁
>> * 原理 : 其内部都维护了一个双向链表，节点Node的值就是每一个请求当前锁的线程，公平锁则在于每次都是从队首取值。
>> * [学习链接](https://www.cnblogs.com/little-fly/p/10365109.html)
> * 排他锁（独占式锁/写锁）
>> * 定义 : 一个锁在某一时刻只能被一个线程占有,其他线程必须等待锁被释放后才可能获取到锁.
>* 共享锁(读锁)
>> * 定义 : 允许多个线程同时获取一个锁,一个锁可以同时被多个线程拥有.
> * 自旋锁 :
>> * 定义 : 当一个线程尝试去获取某一把锁的时候,如果这个锁此时已经被别人获取(占用),那么次线程就无法获取到这把锁,该线程将会等待,
     > 间隔一段时间后会再次尝试获取.这种采用循环加锁->等待的机制被称为"自旋锁".
>> * 原理 : 如果持有锁的线程在短时间内释放锁资源,那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进去阻塞状态,
     > 他们只需要等一等(自旋),等到持有锁的线程释放锁之后即可获取,这样就避免了用户进程和内核切换的消耗.
>> * 与互斥锁区别 : 线程在申请自旋锁的时候,线程不会被挂起,而是处于忙等的状态.
>> * 使用场景 : 锁持有的时间短,而且线程并不希望在重新调度上花太多的成本.
>> * [学习链接](https://www.cnblogs.com/cxuanBlog/p/11679883.html)
> * 乐观锁/悲观锁
>> * [学习链接](https://www.sohu.com/a/306900091_250298)
>
> ### Fork/Join
> * [学习链接](https://www.infoq.cn/article/fork-join-introduction/)

> ### synchronized
>> * 原理 : 采用`以时间换空间的方式`,只提供一份变量让不同的线程排队访问
>> * 侧重点 : 多个线程之间访问资源的同步性


> ### Notify/wait
>> * 在synchronized内部可以调用,wait()是使线程进入等待状态,且释放锁


> ### ReentrantLock--排它锁
>> * ReentrantLock可以替代synchronized进行同步
>> * ReentrantLock获取锁更安全
>> * 使用Condition实现类似synchronized的wait()和notify()功能


> ### ReadWriteLock
>> * ReadWriteLock可以提高读取效率
>> * ReadWriteLock只允许一个线程写入
>> * ReadWriteLock允许多个线程在没有写入时同事读取
>> * 适合读多写少的场景


> ### ThreadLocal
>> * 原理 : 以`空间换时间的方式`为每一个线程都提供一份变量的副本，从而实现同时访问而互不干扰
>> * 侧重点 : 多线程中让每个线程之间的数据相互隔离
>> * 特点 :
>>> * 传递数据 -- 在同一线程，不同组件中传递公共变量 （解耦）
>>> * 线程隔离 -- 在线程并发的情况下，各个线程的数据之间的数据相互隔离。（避免同步方式带来的性能损失）
>> * 与synchronized区别？ -- 并发效率的问题

> ### ThreadPool
> * [参考链接](https://www.cnblogs.com/i-code/p/13917733.html)