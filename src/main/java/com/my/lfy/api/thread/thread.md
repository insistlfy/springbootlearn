> ## Thread  `抢占式调度，具备随机性`
> ### 锁分类
> * 从线程是否需要对资源加锁可以分为 悲观锁 和 乐观锁
> * 从资源已被锁定，线程是否阻塞可以分为 自旋锁
> * 从多个线程并发访问资源，也就是 Synchronized 可以分为 无锁、偏向锁、 轻量级锁 和 重量级锁
> * 从锁的公平性进行区分，可以分为公平锁 和 非公平锁
> * 从根据锁是否重复获取可以分为 可重入锁 和 不可重入锁
> * 从那个多个线程能否获取同一把锁分为 共享锁 和 排他锁
> * [参考链接](https://www.cnblogs.com/Andrew520/p/12149341.html) 
>
> * 可重入锁
>> * 定义 : 指以`线程`为单位，当一个线程获取对象锁之后，这个线程可以可以再次获取本对象上的锁，而其他线程是不可以的;
>> * 原理 : 通过为每个锁关联一个`请求计数器`和一个占有它的线程。当计数为0的时候，认为锁是未占用的；线程请求一个未被占有的锁时，JVM将记录锁的占有者，并且将请求计数器置为1
>。如果同一个线程再次请求这个锁，计数器将递增。每次占用线程退出同步块，计数器值将递减，直到计数器值为0，锁被释放。
>> * 举例 : synchronized , ReentranLock
> * 公平锁/非公平锁  --都属于排他锁
>> * 原理 : 其内部都维护了一个双向链表，节点Node的值就是每一个请求当前锁的线程，公平锁则在于每次都是从队首取值。
>> * [学习链接](https://www.cnblogs.com/little-fly/p/10365109.html)
> * 排他锁（独占式锁）
>> * todo
>* 共享锁
>> * todo
> * 自旋锁
>> * todo
> * 乐观锁
>> * todo
> * 悲观锁
>> * todo
> 
> ### Fork/Join
> * [学习链接](https://www.infoq.cn/article/fork-join-introduction/)

> ### synchronized 
>> * 原理 : 采用`以时间换空间的方式`,只提供一份变量让不同的线程排队访问
>> * 侧重点 : 多个线程之间访问资源的同步性


> ### Notify/wait


> ### ReentrantLock


> ### ReadWriteLock


> ### ThreadLocal
>> * 原理 : 以`空间换时间的方式`为每一个线程都提供一份变量的副本，从而实现同时访问而互不干扰
>> * 侧重点 : 多线程中让每个线程之间的数据相互隔离
>> * 特点 : 
>>> * 传递数据 -- 在同一线程，不同组件中传递公共变量 （解耦）
>>> * 线程隔离 -- 在线程并发的情况下，各个线程的数据之间的数据相互隔离。（避免同步方式带来的性能损失）
>> * 与synchronized区别？ -- 并发效率的问题 